"""
OPTIMIZED STRATEGY DEPLOYMENT
=============================
Deployment Rank: #1
Generated by Institutional Trading System Deployment Module
"""

#!/usr/bin/env python3
"""
Perfect Bollinger Squeeze Live Trading Strategy

Optimized for bar-by-bar ingestion and real-time trading execution.
All logic self-contained with efficient stateful calculations.
"""
import math
from collections import deque

# ==============================================================================
# SECTION 1: CORE STRATEGY PARAMETERS
# These are the optimized logic parameters. They remain in the final script.
# ==============================================================================
bb_period = 25
bb_std_dev = 1.8000
kc_period = 30
kc_atr_multiplier = 2.5000
breakout_period = 15
min_squeeze_bars = 5
use_momentum_filter = True
momentum_period = 18
momentum_threshold = 0.300000
stop_loss_atr_multiplier = 2.2500
atr_period = 14
exit_method = "opposite_band"
exit_donchian_period = 7
risk_reward_ratio = 1.7500
trail_stop_atr_multiplier = 1.7500
use_trend_filter = True
trend_filter_period = 150
volume_filter = False
min_volume_ratio = 1.4000
# Trade timing constraints removed for cleaner strategy logic


# ==============================================================================
# SECTION 2: CORE MARKET & EXECUTION CONFIGURATION  
# These define the financial properties of the traded instrument and execution parameters.
# ==============================================================================
symbol = "ES"
timeframe = "15m"
tick_size = 0.250000
tick_value = 12.5000

# CRITICAL: Position size determined by CLI --contracts-per-trade (single source of truth)
contracts_per_trade = 1

# FENCE:START:SIMULATION
# This block contains simulation-specific parameters and will be stripped for production.
slippage_ticks = 0.500000
commission_per_trade = 2.5000
# FENCE:END:SIMULATION


class LiveBollingerSqueezeStrategy:
    """
    Perfect live trading strategy for bar-by-bar execution.
    Optimized for real-time performance and trading precision.
    """
    
    def __init__(self):
        """Initialize strategy state for live trading."""
        # Position tracking
        self.position = 0  # 1 = long, -1 = short, 0 = flat
        self.entry_price = 0.0
        self.stop_loss = 0.0
        self.target_price = 0.0
        self.bars_in_trade = 0
        self.bars_since_exit = 0
        
        # Efficient data storage with optimal memory usage
        max_lookback = max(bb_period, kc_period, trend_filter_period, breakout_period, momentum_period, exit_donchian_period) + 5
        self.close_prices = deque(maxlen=max_lookback)
        self.high_prices = deque(maxlen=max_lookback)
        self.low_prices = deque(maxlen=max_lookback)
        self.volumes = deque(maxlen=max_lookback)
        
        # Bollinger Bands state (EMA middle + rolling std - EXACT match to indicators.py)
        self.bb_ema = None
        self.bb_ema_alpha = 2.0 / (bb_period + 1)
        self.bb_std = None  # Direct rolling std, not EMA smoothed
        
        # Keltner Channels state
        self.kc_ema = None
        self.kc_ema_alpha = 2.0 / (kc_period + 1)
        
        # ATR state
        self.atr = None
        self.atr_alpha = 2.0 / (atr_period + 1)
        
        # Squeeze tracking with proper duration logic
        self.squeeze_active = False
        self.squeeze_duration = 0
        self.squeeze_group_id = 0
        self.last_squeeze_state = False
        
        # Momentum calculation state
        self.momentum_values = deque(maxlen=momentum_period)
        
        # Trend filter state (EMA-based)
        self.trend_ema = None
        self.trend_ema_alpha = 2.0 / (trend_filter_period + 1)
        
        # Volume tracking for efficient calculation
        self.volume_sum = 0.0
        self.volume_count = 0
        
        # Breakout and exit channel tracking
        self.breakout_highs = deque(maxlen=breakout_period)
        self.breakout_lows = deque(maxlen=breakout_period)
        self.exit_highs = deque(maxlen=exit_donchian_period)
        self.exit_lows = deque(maxlen=exit_donchian_period)
        
        # Previous bar data
        self.prev_close = None
        self.prev_high = None
        self.prev_low = None
        self.bar_count = 0
        
        # CRITICAL: Pending signal execution (matches backtest timing)
        # Signal detected on bar N, executed at bar N+1 open price
        self.pending_entry_signal = 0      # 0=none, 1=long, -1=short
        self.pending_stop_loss = 0.0       # Stop-loss level for pending signal
        self.pending_target_price = 0.0    # Target price for pending signal
        self.pending_atr = 0.0             # ATR value when signal was generated
        
        # Trading constraints removed for cleaner strategy logic
        
        # Performance optimization - removed since fidelity > optimization
        # Focus: perfect match to backtest logic, not premature optimization
    
    def update_bollinger_bands_ema(self, close):
        """
        Update Bollinger Bands using EMA for live trading consistency.
        Optimized for real-time calculation efficiency.
        """
        if self.bb_ema is None:
            # Initialize with first close price
            self.bb_ema = close
            return None, None, None
        
        # Update EMA efficiently
        self.bb_ema = (close * self.bb_ema_alpha) + (self.bb_ema * (1 - self.bb_ema_alpha))
        
        # Calculate standard deviation using standard rolling method (matches backtest)
        if len(self.close_prices) >= bb_period:
            # Use standard rolling standard deviation calculation
            recent_prices = list(self.close_prices)[-bb_period:]
            
            # Standard rolling std calculation (matches indicators.py)
            mean_price = sum(recent_prices) / len(recent_prices)
            variance = sum((price - mean_price) ** 2 for price in recent_prices) / (len(recent_prices) - 1)
            self.bb_std = math.sqrt(max(variance, 0.0001))  # Prevent negative sqrt
            
            # Calculate bands
            upper = self.bb_ema + (self.bb_std * bb_std_dev)
            lower = self.bb_ema - (self.bb_std * bb_std_dev)
            
            self._last_bb_calculation = (upper, self.bb_ema, lower)
            return upper, self.bb_ema, lower
        
        return None, None, None
    
    def update_keltner_channels(self, close):
        """Update Keltner Channels for live trading."""
        if self.kc_ema is None:
            self.kc_ema = close
            return None, None, None
        
        # Update EMA efficiently
        self.kc_ema = (close * self.kc_ema_alpha) + (self.kc_ema * (1 - self.kc_ema_alpha))
        
        if self.atr is None:
            return None, None, None
        
        # Calculate channels
        channel_width = self.atr * kc_atr_multiplier
        upper = self.kc_ema + channel_width
        lower = self.kc_ema - channel_width
        
        self._last_kc_calculation = (upper, self.kc_ema, lower)
        return upper, self.kc_ema, lower
    
    def update_atr(self, high, low, close):
        """Update ATR calculation optimized for live trading."""
        if self.prev_close is None:
            # First bar - use high-low
            true_range = high - low
        else:
            # Calculate true range components efficiently
            high_low = high - low
            high_close = abs(high - self.prev_close)
            low_close = abs(low - self.prev_close)
            true_range = max(high_low, high_close, low_close)
        
        # Update ATR using EMA (more efficient than storing all values)
        if self.atr is None:
            self.atr = true_range
        else:
            self.atr = (true_range * self.atr_alpha) + (self.atr * (1 - self.atr_alpha))
    
    def detect_squeeze_with_duration(self, bb_upper, bb_lower, kc_upper, kc_lower):
        """
        Detect squeeze and track duration for live trading.
        Optimized state tracking for real-time execution.
        """
        if None in [bb_upper, bb_lower, kc_upper, kc_lower]:
            return False, 0
        
        # Detect squeeze condition on current bar
        current_squeeze = (bb_upper < kc_upper) and (bb_lower > kc_lower)
        
        # Efficient squeeze duration tracking
        if current_squeeze != self.last_squeeze_state:
            # State change detected
            if current_squeeze:
                self.squeeze_duration = 1
                self.squeeze_active = True
            else:
                self.squeeze_duration = 0
                self.squeeze_active = False
        else:
            # Same state - continue counting if in squeeze
            if current_squeeze:
                self.squeeze_duration += 1
                self.squeeze_active = True
            else:
                self.squeeze_duration = 0
                self.squeeze_active = False
        
        self.last_squeeze_state = current_squeeze
        return current_squeeze, self.squeeze_duration
    
    def calculate_momentum_linear_regression(self):
        """
        Calculate momentum using linear regression slope.
        Optimized for live trading performance.
        """
        if len(self.momentum_values) < momentum_period:
            return 0.0
        
        # Get recent values efficiently
        values = list(self.momentum_values)[-momentum_period:]
        n = len(values)
        
        if n < 2:
            return 0.0
        
        # Optimized linear regression calculation
        sum_x = n * (n - 1) / 2  # Sum of 0,1,2,...,n-1
        sum_y = sum(values)
        sum_xy = sum(i * values[i] for i in range(n))
        sum_x2 = n * (n - 1) * (2 * n - 1) / 6  # Sum of squares
        
        # Calculate slope
        denominator = n * sum_x2 - sum_x * sum_x
        if abs(denominator) < 1e-10:
            return 0.0
        
        slope = (n * sum_xy - sum_x * sum_y) / denominator
        return slope
    
    def update_donchian_channels(self, high, low):
        """Update Donchian channels efficiently for live trading."""
        self.breakout_highs.append(high)
        self.breakout_lows.append(low)
        self.exit_highs.append(high)
        self.exit_lows.append(low)
    
    def get_breakout_levels(self):
        """Get current breakout levels for live trading."""
        if len(self.breakout_highs) < breakout_period or len(self.breakout_lows) < breakout_period:
            return None, None
        
        # For live trading, use all available data
        breakout_high = max(self.breakout_highs)
        breakout_low = min(self.breakout_lows)
        
        return breakout_high, breakout_low
    
    def get_exit_levels(self):
        """Get current exit levels efficiently."""
        if len(self.exit_highs) < exit_donchian_period or len(self.exit_lows) < exit_donchian_period:
            return None, None
        
        exit_high = max(self.exit_highs)
        exit_low = min(self.exit_lows)
        
        return exit_high, exit_low
    
    def update_trend_filter(self, close):
        """Update trend filter using EMA for live trading consistency."""
        if not use_trend_filter:
            return True, True
        
        if self.trend_ema is None:
            self.trend_ema = close
            return True, True  # Allow trades initially
        
        # Update trend EMA efficiently
        self.trend_ema = (close * self.trend_ema_alpha) + (self.trend_ema * (1 - self.trend_ema_alpha))
        
        long_trend = close > self.trend_ema
        short_trend = close < self.trend_ema
        
        return long_trend, short_trend
    
    def check_volume_filter(self, volume):
        """Check volume filter efficiently for live trading."""
        if not volume_filter:
            return True
        
        # Efficient volume tracking
        if len(self.volumes) >= bb_period:
            recent_volumes = list(self.volumes)[-bb_period:]
            avg_volume = sum(recent_volumes) / len(recent_volumes)
            volume_ratio = volume / avg_volume if avg_volume > 0 else 1.0
            return volume_ratio >= min_volume_ratio
        
        return True  # Allow trades initially
    
    # REMOVED: calculate_position_size() method
    # Position sizing now determined by CLI --contracts-per-trade parameter (single source of truth)
    # This ensures institutional compliance: deterministic, auditable, no contradictory logic
    
    def check_exit_conditions(self, close, bb_upper, bb_lower):
        """Check all exit conditions for current position."""
        if self.position == 0:
            return False, ""
        
        # Priority 1: Stop loss (most important)
        if self.position > 0 and close <= self.stop_loss:
            return True, "stop_loss"
        elif self.position < 0 and close >= self.stop_loss:
            return True, "stop_loss"
        
        # Priority 2: Exit method specific conditions
        if exit_method == "trailing_donchian":
            exit_high, exit_low = self.get_exit_levels()
            if exit_high is not None and exit_low is not None:
                if self.position > 0 and close < exit_low:
                    return True, "trailing_donchian_long"
                elif self.position < 0 and close > exit_high:
                    return True, "trailing_donchian_short"
        
        elif exit_method == "opposite_band":
            if bb_upper is not None and bb_lower is not None:
                if self.position > 0 and close >= bb_upper:
                    return True, "opposite_band_long"
                elif self.position < 0 and close <= bb_lower:
                    return True, "opposite_band_short"
        
        elif exit_method == "fixed_rr":
            if self.position > 0 and close >= self.target_price:
                return True, "fixed_rr_long"
            elif self.position < 0 and close <= self.target_price:
                return True, "fixed_rr_short"
        
        # Maximum bars safety removed for cleaner strategy logic
        
        return False, ""
    
    def process_new_bar(self, bar_data, account_balance=100000):
        """
        Process new bar for live trading - main entry point.
        
        Args:
            bar_data: Dict with 'open', 'high', 'low', 'close', 'volume', 'timestamp'
            account_balance: Account balance for position sizing
            
        Returns:
            dict: Complete trading decision with all details
        """
        self.bar_count += 1
        
        # Extract bar data
        open_price = bar_data['open']
        high = bar_data['high']
        low = bar_data['low']
        close = bar_data['close']
        volume = bar_data['volume']
        timestamp = bar_data.get('timestamp', None)
        
        # Store current bar data
        self.close_prices.append(close)
        self.high_prices.append(high)
        self.low_prices.append(low)
        self.volumes.append(volume)
        
        # ======================================================================
        # PRIORITY 0: EXECUTE PENDING SIGNALS AT OPEN PRICE (GOLD STANDARD)
        # Process signals generated on previous bar, execute at current bar open
        # This creates perfect 1:1 timing match with backtest execution model
        # ======================================================================
        if self.pending_entry_signal != 0:
            # Execute pending signal at current bar's open price
            self.position = self.pending_entry_signal
            self.entry_price = open_price  # KEY: Use open price like backtest
            self.stop_loss = self.pending_stop_loss
            self.target_price = self.pending_target_price
            
            # Update position state
            self.bars_in_trade = 1
            self.bars_since_exit = 0
            
            # Create execution decision record
            execution_decision = {
                'timestamp': timestamp,
                'bar_count': self.bar_count,
                'action': 'BUY' if self.position == 1 else 'SELL',
                'signal': self.position,
                'price': open_price,  # Executed at open price
                'position_size': contracts_per_trade,
                'stop_loss': self.stop_loss,
                'target_price': self.target_price,
                'reason': f'{"long" if self.position == 1 else "short"}_breakout_executed_at_open',
                'position_info': self.get_current_position_info(),
                'indicators': {}  # Will be populated below
            }
            
            # Clear pending signal
            self.pending_entry_signal = 0
            self.pending_stop_loss = 0.0
            self.pending_target_price = 0.0
            self.pending_atr = 0.0
            
            # Return execution decision (skip rest of bar processing for clarity)
            trading_decision = execution_decision
        else:
            # ======================================================================
            # STEP 1: MAKE ALL DECISIONS USING PRE-EXISTING STATE (NO LOOK-AHEAD BIAS)
            # All decisions must use data available BEFORE this new bar arrived
            # ======================================================================
            
            # Critical: Get breakout levels BEFORE updating with current bar data
            breakout_high_clean, breakout_low_clean = self.get_breakout_levels()
            
            # Initialize trading decision
            trading_decision = {
                'timestamp': timestamp,
                'bar_count': self.bar_count,
                'action': 'HOLD',  # HOLD, BUY, SELL, EXIT
                'signal': 0,       # 0=hold, 1=buy, -1=sell, 2=exit
                'price': close,
                'position_size': 0,
                'stop_loss': None,
                'target_price': None,
                'reason': '',
                'position_info': self.get_current_position_info(),
                'indicators': {}
            }
        
        # Need minimum data for calculations
        if self.bar_count < max(bb_period, kc_period, atr_period):
            trading_decision['reason'] = 'insufficient_data'
            self._update_previous_bar_data(high, low, close)
            return trading_decision
        
        # Calculate indicators
        bb_upper, bb_middle, bb_lower = self.update_bollinger_bands_ema(close)
        kc_upper, kc_middle, kc_lower = self.update_keltner_channels(close)
        
        # Store indicator values for monitoring
        trading_decision['indicators'] = {
            'bb_upper': bb_upper, 'bb_middle': bb_middle, 'bb_lower': bb_lower,
            'kc_upper': kc_upper, 'kc_middle': kc_middle, 'kc_lower': kc_lower,
            'atr': self.atr,
            'squeeze_duration': self.squeeze_duration,
            'momentum': self.calculate_momentum_linear_regression() if len(self.momentum_values) >= momentum_period else 0
        }
        
        # Update position tracking
        if self.position != 0:
            self.bars_in_trade += 1
        elif self.bars_since_exit > 0:
            self.bars_since_exit += 1
        
        # PRIORITY 1: Handle exits first (if in position)
        if self.position != 0:
            exit_triggered, exit_reason = self.check_exit_conditions(close, bb_upper, bb_lower)
            
            if exit_triggered:
                self.position = 0
                self.bars_since_exit = 1
                self.bars_in_trade = 0
                
                trading_decision.update({
                    'action': 'EXIT',
                    'signal': 2,
                    'reason': exit_reason
                })
                
                self._update_previous_bar_data(high, low, close)
                return trading_decision
        
        # PRIORITY 2: Check for new entries (if flat)
        if self.position == 0:
            
            # Detect squeeze conditions
            squeeze_active, squeeze_duration = self.detect_squeeze_with_duration(
                bb_upper, bb_lower, kc_upper, kc_lower
            )
            
            # Check minimum squeeze duration
            squeeze_ready = squeeze_duration >= min_squeeze_bars
            
            # Use the clean breakout levels calculated before state updates  
            breakout_high, breakout_low = breakout_high_clean, breakout_low_clean
            
            if breakout_high is not None and breakout_low is not None:
                # Check breakout conditions
                long_breakout = close > breakout_high
                short_breakout = close < breakout_low
                
                # Check all filters
                if use_momentum_filter:
                    momentum = self.calculate_momentum_linear_regression()
                    momentum_bullish = momentum > momentum_threshold
                    momentum_bearish = momentum < -momentum_threshold
                else:
                    momentum_bullish = True
                    momentum_bearish = True
                
                long_trend, short_trend = self.update_trend_filter(close)
                volume_ok = self.check_volume_filter(volume)
                
                # GOLD STANDARD: PENDING SIGNAL LOGIC (matches backtest timing)
                if (squeeze_ready and long_breakout and momentum_bullish and long_trend and volume_ok):
                    # CRITICAL: Set pending signal instead of executing immediately
                    # Signal detected on current bar, will execute at NEXT bar open price
                    self.pending_entry_signal = 1
                    self.pending_atr = self.atr
                    
                    # Pre-calculate stop-loss and target based on current close (signal bar)
                    self.pending_stop_loss = close - (self.atr * stop_loss_atr_multiplier)
                    if exit_method == "fixed_rr":
                        # Calculate target using signal bar close for R:R ratio consistency
                        risk_distance = abs(close - self.pending_stop_loss)
                        self.pending_target_price = close + (risk_distance * risk_reward_ratio)
                    else:
                        self.pending_target_price = 0.0
                    
                    # FENCE:START:SIMULATION
                    # Adjust target for costs if in simulation mode
                    if 'slippage_ticks' in globals() and exit_method == "fixed_rr":
                        cost_in_price = ((slippage_ticks * 2 * tick_value) + (commission_per_trade * 2)) / (tick_value / tick_size)
                        self.pending_target_price += cost_in_price
                    # FENCE:END:SIMULATION

                    trading_decision = {
                        'timestamp': timestamp,
                        'bar_count': self.bar_count,
                        'action': 'SIGNAL_PENDING',  # Indicates pending signal, not immediate execution
                        'signal': 1,
                        'price': close,  # Signal price (will execute at next open)
                        'position_size': contracts_per_trade,
                        'stop_loss': self.pending_stop_loss,
                        'target_price': self.pending_target_price,
                        'reason': 'long_breakout_signal_pending',
                        'position_info': self.get_current_position_info(),
                        'indicators': trading_decision['indicators']
                    }

                elif (squeeze_ready and short_breakout and momentum_bearish and short_trend and volume_ok):
                    # CRITICAL: Set pending signal instead of executing immediately
                    # Signal detected on current bar, will execute at NEXT bar open price
                    self.pending_entry_signal = -1
                    self.pending_atr = self.atr
                    
                    # Pre-calculate stop-loss and target based on current close (signal bar)
                    self.pending_stop_loss = close + (self.atr * stop_loss_atr_multiplier)
                    if exit_method == "fixed_rr":
                        # Calculate target using signal bar close for R:R ratio consistency
                        risk_distance = abs(self.pending_stop_loss - close)
                        self.pending_target_price = close - (risk_distance * risk_reward_ratio)
                    else:
                        self.pending_target_price = 0.0
                    
                    # FENCE:START:SIMULATION
                    # Adjust target for costs if in simulation mode
                    if 'slippage_ticks' in globals() and exit_method == "fixed_rr":
                        cost_in_price = ((slippage_ticks * 2 * tick_value) + (commission_per_trade * 2)) / (tick_value / tick_size)
                        self.pending_target_price -= cost_in_price
                    # FENCE:END:SIMULATION

                    trading_decision = {
                        'timestamp': timestamp,
                        'bar_count': self.bar_count,
                        'action': 'SIGNAL_PENDING',  # Indicates pending signal, not immediate execution
                        'signal': -1,
                        'price': close,  # Signal price (will execute at next open)
                        'position_size': contracts_per_trade,
                        'stop_loss': self.pending_stop_loss,
                        'target_price': self.pending_target_price,
                        'reason': 'short_breakout_signal_pending',
                        'position_info': self.get_current_position_info(),
                        'indicators': trading_decision['indicators']
                    }
        
        # ======================================================================
        # STEP 2: UPDATE STATE WITH CURRENT BAR DATA (PREPARE FOR NEXT BAR)
        # Only after all decisions are made, update state with current bar data
        # ======================================================================
        
        # Now it's safe to update indicators with current bar data for next iteration
        self.update_atr(high, low, close)
        self.update_donchian_channels(high, low)
        self.momentum_values.append(close)
        
        # Update previous bar data
        self._update_previous_bar_data(high, low, close)
        
        return trading_decision
    
    def _update_previous_bar_data(self, high, low, close):
        """Update previous bar data for next calculation."""
        self.prev_high = high
        self.prev_low = low
        self.prev_close = close
    
    def get_current_position_info(self):
        """Get current position information for monitoring."""
        unrealized_pnl = 0.0
        if self.position != 0 and self.prev_close is not None:
            if self.position > 0:
                unrealized_pnl = (self.prev_close - self.entry_price) * abs(self.position)
            else:
                unrealized_pnl = (self.entry_price - self.prev_close) * abs(self.position)
        
        return {
            'position': self.position,
            'entry_price': self.entry_price,
            'stop_loss': self.stop_loss,
            'target_price': self.target_price,
            'bars_in_trade': self.bars_in_trade,
            'bars_since_exit': self.bars_since_exit,
            'unrealized_pnl': unrealized_pnl
        }
    
    def get_strategy_status(self):
        """Get complete strategy status for monitoring."""
        return {
            'position_info': self.get_current_position_info(),
            'indicators': {
                'bb_ema': self.bb_ema,
                'bb_std': self.bb_std,
                'kc_ema': self.kc_ema,
                'atr': self.atr,
                'squeeze_active': self.squeeze_active,
                'squeeze_duration': self.squeeze_duration,
                'trend_ema': self.trend_ema,
                'momentum': self.calculate_momentum_linear_regression() if len(self.momentum_values) >= momentum_period else 0
            },
            'system_info': {
                'bar_count': self.bar_count,
                'data_ready': self.bar_count >= max(bb_period, kc_period, atr_period),
                'memory_usage': {
                    'close_prices': len(self.close_prices),
                    'momentum_values': len(self.momentum_values),
                    'breakout_highs': len(self.breakout_highs)
                }
            }
        }


def create_live_strategy():
    """Factory function to create live trading strategy instance."""
    return LiveBollingerSqueezeStrategy()


# Example usage for live trading
if __name__ == "__main__":
    # Create strategy instance
    strategy = create_live_strategy()
    
    # Example live bar processing
    live_bar = {
        'timestamp': '2025-01-01 09:30:00',
        'open': 4200.25,
        'high': 4205.75,
        'low': 4198.50,
        'close': 4203.00,
        'volume': 15000
    }
    
    # Process new bar
    decision = strategy.process_new_bar(live_bar, account_balance=100000)
    
    print("Live Trading Decision:")
    print(f"Action: {decision['action']}")
    print(f"Signal: {decision['signal']}")
    print(f"Price: {decision['price']}")
    print(f"Reason: {decision['reason']}")
    print(f"Position Info: {decision['position_info']}")
    
    # Get strategy status
    status = strategy.get_strategy_status()
    print(f"\nStrategy Status: {status}")